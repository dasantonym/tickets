module.exports = function () {
    var http = require('http'),
        db = require('./db'),
        connect = require('connect'),
        cors = require('cors'),
        async = require('async'),
        bodyParser = require('body-parser'),
        app = connect();
    app.use(cors());
    app.use(bodyParser.json());
    app.use(function (req, res) {
        var querySplit = req.url.split('?');
        var baseurl = querySplit[0];
        var token = null;
        if (querySplit.length > 1) {
            token = querySplit[1];
        }
        switch (baseurl) {
            case '/api/tickets.json':
                db.find({}, function (err, tickets) {
                    res.contentType = 'application/json';
                    if (err) {
                        res.statusCode = 400;
                        res.end(JSON.stringify(err));
                    } else {
                        res.end(JSON.stringify(tickets));
                    }
                });
                break;
            case '/api/tickets/void.json':
                async.waterfall([
                    function (cb) {
                        db.findOne({ token: token }, cb);
                    },
                    function (ticket, cb) {
                        if (ticket) {
                            if (ticket.void) {
                                cb(new Error('Ticket already claimed at ' + ticket.void_at), null);
                            } else {
                                ticket.void = true;
                                ticket.void_at = new Date();
                                ticket.updated_at = new Date();
                                db.update(ticket, token, function (err) {
                                    if (err) {
                                        return cb(err);
                                    }
                                    if (settings.push.url) {
                                        sync.addPendingUpdate(ticket.uuid, ticket, function (err) {
                                            cb(err, ticket);
                                        });
                                    } else {
                                        cb(err, ticket);
                                    }
                                });
                            }
                        } else {
                            cb(new Error('Ticket not found'), null);
                        }
                    }
                ], function (err, ticket) {
                    if (err) {
                        res.end(JSON.stringify({ error: err.message }));
                    } else {
                        res.end(JSON.stringify({ success: true, ticket: ticket }));
                    }
                });
                break;
            case '/api/tickets/push.json':
                async.waterfall([
                    function (cb) {
                        db.findOne({uuid: req.body.ticket_uuid}, cb);
                    },
                    function (ticket, cb) {
                        if (ticket) {
                            if (ticket.updated_at < req.body.update.updated_at) {
                                db.update(req.body, token, function (err) {
                                    cb(err);
                                });
                            } else {
                                cb(new Error('outdated'));
                            }
                        } else {
                            db.create(req.body.update, cb);
                        }
                    }
                ], function (err, ticket) {
                    if (err) {
                        if (err.message === 'outdated') {
                            res.statusCode = 400;
                        } else {
                            res.statusCode = 500;
                        }
                        res.end(JSON.stringify({error: err.message}));
                    } else {
                        res.end(JSON.stringify({}));
                    }
                });
                break;
            default:
                res.statusCode = 404;
                res.end();
                break;
        }
    });
    http.createServer(app).listen(9999);
};